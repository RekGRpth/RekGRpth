Меня зовут Георгий и тема моего доклада:

Прикладная логика внутри базы данных. Шаблонизация. Рендеринг. Рассылка. Примеры.

Как вообще мне пришла в голову такая идея - поместить прикладную логику внутрь базы данных? В то время как очень многим не нравится помещать в базу данных даже бизнес логику!
Я много лет проработал с биллингом и поэтому под бизнес логикой внутри базы данных понимаю всякие вычисления, ограничения, внешние ключи, хранимые процедуры, функции, триггеры и т.д.,
а под прикладной логикой всякие действия: шаблонизировать документ, отрендерить его в pdf, отослать pdf по электронной почте, послать смс о необходимости пополнить баланс, включить/выключить телефон на телефонной станции или интернет на циске/микротике и т.д.
Конечно, все эти действия можно делать и вне базы данных, и так все обычно и делают. Но тогда возникает потребность в инфраструктуре для всего этого, как всё это запускать, параллелить, мониторить, обслуживать и т.д.
А у меня как раз есть планировщик асинхронных заданий [pg_task](https://github.com/RekGRpth/pg_task), в котором всё это уже реализовано, т.е. автоматический запуск, распараллеливание, в качестве мониторинга всё пишется обратно в таблицу в базе данных, даже транзакционность присутствует!
К тому же, если уже есть база данных и планировщик, то дополнительно не надо никакой инфраструктуры городить и управлять только базой данных гораздо проще.
Вот так у меня и возникла идея поместить не только бизнес логику, но и прикладную логику тоже внутрь базы данных.
Для этого пришлось написать несколько плагинов для постгреса. Большинство из них простые и действуют по принципу: вызывается функция из расширения, в которую в качестве аргументов что-то передаётся и она возвращает результат.
На время работы этой функции запрос как бы подвисает, потому что база постгрес не асинхронная. Поэтому также нет никакого смысла использовать так реализованную прикладную логику внутри базы из внешних клиентов к базе.
Гораздо проще реализовать эту логику на клиенте базы. Именно для этого, чтобы бессмысленно не использовать клиентов базы, как раз и используется планировщик асинхронных заданий, который выполняет прикладную логику независимо от клиентов базы.
Так работает шаблонизация и рендеринг.

Итак,

Шаблонизация.

Когда я начинал, мне попался шаблонизатор [ctpp2](https://github.com/Azq2/ctpp2), написанный на C++ и с реализацией в виде плагина [ngx_ctpp2](https://github.com/RekGRpth/ngx_ctpp2) к nginx, с интересной особенностью - для использования его шаблоны необходимо было компилировать.
Компилятор представлял консольную программу, которая переводила текстовый файл шаблона в бинарный. У меня шаблоны, как и сами документы хранились внутри базы данных и поэтому мне не очень хотелось вызывать внешнюю программу внутри базы данных, хотя это и возможно делать с помощью расширения [plsh](https://github.com/petere/plsh).
Можно ещё, конечно, внутри базы данных хранить уже скомпилированные шаблоны, но это тоже так себе идея.
Поэтому я стал искать другой шаблонизатор с реализацией на C и нашёл [mustache](https://mustache.github.io), у которого есть реализации почти на всех языках! На C реализация называется [mustach](https://gitlab.com/jobol/mustach).
Также, нашёл [handlebars.js](https://github.com/handlebars-lang/handlebars.js) - надмножество mustache, с реализацией на C [handlebars.c](https://github.com/jbboehr/handlebars.c) и многих других языках.
Оба эти шаблонизатора я прикрутил в виде плагинов в постгрес [pg_mustach](https://github.com/RekGRpth/pg_mustach), [pg_handlebars](https://github.com/RekGRpth/pg_handlebars)
и nginx [ngx_http_mustach_module](https://github.com/RekGRpth/ngx_http_mustach_module), [ngx_http_handlebars_module](https://github.com/RekGRpth/ngx_http_handlebars_module),
а также в питон [pymustach](https://github.com/RekGRpth/pymustach), [pyhandlebars](https://github.com/RekGRpth/pyhandlebars) для сравнения производительности с нативными питоновыми реализациями (сишная версия mustache оказалась на порядок быстрее питоновой).
Как уже говорилось выше, интерфейс для шаблонизации очень простой. Вызывается функция, в которую в качестве аргументов передаётся документ в виде json, и шаблон в виде текста, функция шаблонизирует и возвращает результат в виде текста.
Например, следующий запрос
```sql
SELECT mustach('{"a":"b"}', '{{a}}');
```
вернёт
```sql
b
```
Более сложный пример
```sql
SELECT mustach('{"people":[
    {"firstName":"Yehuda","lastName":"Katz"},
    {"firstName":"Carl","lastName":"Lerche"},
    {"firstName":"Alan","lastName":"Johnson"}
]}', '<ul>{{#people}}<li>{{firstName}} {{lastName}}</li>{{/people}}</ul>');
```
вернёт
```sql
<ul><li>Yehuda Katz</li><li>Carl Lerche</li><li>Alan Johnson</li></ul>
```
Интерфейс у handlebars абсолютно идентичный.
Из интересных особенностей реализации mustach могу отметить, что результат выполнения передаётся через файл в оперативной памяти, который предварительно создаётся функцией
```c
file = open_memstream(&data, &len)
```
Далее этот файл передаётся в библиотеку [mustach](https://gitlab.com/jobol/mustach), которая пишет в него результат шаблонизации. Потом результат считать довольно просто через указатель на данные и их длину.
Библиотека [mustach](https://gitlab.com/jobol/mustach) может работать с разными json-парсерами, в ней уже реализованы [cJSON](https://github.com/DaveGamble/cJSON), [jansson](https://github.com/akheron/jansson) и [json_c](https://github.com/json-c/json-c).
Для постгреа логично было бы реализовать парсер на основе json(b), но я уже не стал так упарываться и использовал готовые реализации.
Шаблонизация сама по себе в биллинге мало чем полезна, поэтому мне понадобился ещё и

Рендеринг.

Здесь под рендерингом я понимаю преобразование HTML-файла в PDF-файл. Для этого я нашёл несколько библиотек и все их прикрутил в виде плагинов в постгрес и nginx, а также парочку в питон.
Итак, первым я нашёл [wkhtmltopdf](https://github.com/wkhtmltopdf/wkhtmltopdf) - довольно тяжёлая библиотека, написанная на C++ с биндингом в C. [pg_wkhtmltopdf](https://github.com/RekGRpth/pg_wkhtmltopdf) и [ngx_http_wkhtmltopdf_module](https://github.com/RekGRpth/ngx_http_wkhtmltopdf_module).
Мало того, что она занимает много места, так ещё и активно использует треды и не очень охотно их освобождает/завершает, что особенно плохо при работе в nginx. Но надо отдать должное, апи у неё удобное.
Поэтому я стал искать дальше и нашёл wthtmltopdf, точнее, прямо такой библиотеки нет, но я её выдрал из фреймворка [wt](https://www.webtoolkit.eu/wt), в котором был рендеринг PDF на C++, а я только дописал биндинг в C по аналогии с wkhtmltopdf.
[pg_wthtmltopdf](https://github.com/RekGRpth/pg_wthtmltopdf) и [ngx_http_wthtmltopdf_module](https://github.com/RekGRpth/ngx_http_wthtmltopdf_module). Но тоже мне она не очень понравилась, потому, что требует либы для плюсов.
И я нашёл чисто сишную библиотеку [mupdf](https://github.com/RekGRpth/mupdf). [pg_mupdf](https://github.com/RekGRpth/pg_mupdf), [ngx_http_mupdf_module](https://github.com/RekGRpth/ngx_http_mupdf_module) и [pymupdf](https://github.com/RekGRpth/pymupdf). 
Довольно приятная библиотека с очень удобным апи, есть возможность задать кастомные аллокаторые (я задал пострессовые), есть механизм try/catch, очень похожий на постгрессовый. Из недостатков мне показалось, что она занимала тоже слишком много места для докер образа.
Наконец, я нашёл консольную утилиту [htmldoc](https://github.com/RekGRpth/htmldoc), написанную на C с элементами на C++, но что мне больше всего понравилось, так это её конечный размер всего в несколько мегабайт! К сожалению, она не была готова в виде разделяемой библиотеки, поэтому мне пришлось это доделывать самому.
Несколько правок в мейкфайле и у меня появилась разделяемая библиотека наряду с консольной утилитой.
[pg_htmldoc](https://github.com/RekGRpth/pg_htmldoc), [ngx_http_htmldoc_module](https://github.com/RekGRpth/ngx_http_htmldoc_module) и [pyhtmldoc](https://github.com/RekGRpth/pyhtmldoc).
Постгресовый интерфейс я к ней сделал тоже очень простой. Несколько функций, которые добавляют файл, или текст или урл в контекст, и ещё пара функций для преобразования в PDF или PS всего, что было добавлено в контекст. В результате преобразования, очевидно, получается не текст, а бинарь.
```sql
select htmldoc_addurl('https://github.com');
copy (
    select convert2pdf()
) to 'htmldoc.pdf' WITH (FORMAT binary, HEADER false)
```
Здесь также, не только результат выполнения передаётся через файл в оперативной памяти
```c
out = open_memstream(&output_data, &output_len)
```
но также и сам HTML-текст в одном случае передаётся через похожий файл в оперативной памяти, но уже с помощью другой родственной функции
```c
in = fmemopen((void *)html, len, "rb")
```
При освобождении постгресового мемори контекста очищается и контекст расширения.
Рендеринг PDF-ок, конечно хорошо, но для их передачи клиентам необходима

Рассылка.

Казалось бы причём тут рассылка электронной почты и курл?! А вот, оказывается, курл умеет не только в HTTP-запросы, но также и FTP, SMTP и ещё кучу других полезных протоколов!
Изначально мне попался плагин к постгресу [pgsql-http](https://github.com/pramsey/pgsql-http), я его очень подробно изучил и мне он очень понравился за исключением того, что он использует лишь малую часть библиотеки [curl](https://github.com/curl/curl), а также мне показалась слишком сложной реализация формата запроса.
Надо сказать, этот плагин ошибочно полагает, что [curl](https://github.com/curl/curl) возвращает текст. На самом деле, это не так и он возвращает бинарные данные, которые уже потом можно преобразовать в текст, зная кодировку.
Например, слово "Привет" - это текст, но для записи его на диск, надо указать кодировку. В кодировке UTF-8 это будет одна последовательность байт, в кодировке KOI8-R - совсем другая, а в кодировке Windows-1251 - третья. Ошибочно полагать, что HTTP-запрос всегда вернёт текст в кодировке UTF-8!
Ещё я нашёл [pg_net](https://github.com/supabase/pg_net), позволяющую делать асинхронные HTTP(S) запросы, с помощью очередей в таблице и фонового рабочего процесса.
У неё окакзались те же недостатки и поэтому запилил свою версию - [pg_curl](https://github.com/RekGRpth/pg_curl), в которой по максимуму реализовал почти все возможности курла, а именно, сделал интерфейс почти ко всем функциям, которые принимают строковые или числовые аргументы.
И теперь я могу прямо из базы делать не только HTTP-запросы, но и отсылать электронную почту или копировать файлы по FTP или SCP! Все функции pg_curl можно разделить на несколько типов. Есть простые функции, которые устанавливают всевозможные опции курла.
Также, есть простые функции, которые добавляют заголовки, а также файлы, аттачи и т.п. Ещё есть простые функции, которые получают различные результаты запросов. И, наконец, есть довольно сложная функция, которая запускает собственно выполнение запроса в курле.
До недавнего времени, я использовал лишь curl_easy_perform, что позволяло одновременно выполнять только один запрос. Но этим летом я значительно усовершенствовал расширение, добавив поддержку curl_multi_perform, что позволило делать несколько запросов одновременно.
Причём поменял сигнатуры всех функций настолько мягко, что если бы кто-то использовал старую версию [pg_curl](https://github.com/RekGRpth/pg_curl), а потом скомпилировал новую, то у него бы ничего не сломалось и без обновления расширения командой ALTER EXTENSION UPDATE!
Из интересного можно отметить, что курл позволяет задать кастомное управление памятью, чем я и воспользовался передав туда управление через постгресовые мемори контексты.
Алексей заметил, что при этом курл использует мультитредовый резолвинг, что иногда приводило к сегфолтам, поэтому я во все врапперы над постгрессовыми мемори контекстами, передаваемыми курлу, добавил мьютексы, чтобы убедиться, что никакой тред параллельно не вызовет соответствующие функции.
Также я добавил огромное число ifdef-ов для поддержки всевозможных версий курла. Если какая-то функция ещё не поддерживается текущей старой версией курла, или наоборот, в текущей новой версии курла удалили какую-то уже устаревшую функцию, то выдаётся соответствующее сообщение об ошибке.
Ну и по-традиции, я пока поддерживаю все версии постгресса, начиная с 9.4 и включая 17, на которых расширение собирается и немного тестируется.
Итак,

Примеры.

1.Рассылка электронной почты с отчётом о доставке

Для отчёта о доставке писем мне понадобился свой локальный почтовый сервер [opensmtpd](https://www.opensmtpd.org), который через плагин [pgsql](gawkextlib.sourceforge.net/pgsql/pgsql.html) к [gawk](https://www.gnu.org/software/gawk) как раз и пишет в базу информацию о доставке.
Всё оставльное я реализовал прямо в базе с помощью плагина [pg_curl](https://github.com/RekGRpth/pg_curl) и планировщика асинхронных заданий [pg_task](https://github.com/RekGRpth/pg_task). На таблицу с письмами я навешал триггер, который после вставки создаёт задачу на отправку письма.
Также, я сделал интерфейс для массовой рассылки писем по таблице из CSV-файла, в котором можно указать колонки с отправителем, получателем, а также с другими переменными, которые будут подставляться в тему и тело письма с помощью шаблонизатора [pg_mustach](https://github.com/RekGRpth/pg_mustach).
Можно добавлять вложения, а при необходимости, шаблонизировать их с помощью шаблонизатора [pg_mustach](https://github.com/RekGRpth/pg_mustach) и/или пеобразовывать их в PDF с помощью [pg_htmldoc](https://github.com/RekGRpth/pg_htmldoc).
Кроме этого, я ещё сделал организацию рассылки писем со счетами на оплату по условиям из биллинга.

2.Рассылка СМС

Аналогичным образом через REST-интерфейс оператора связи я реализовал рассылку СМС прямо в базе с помощью плагина [pg_curl](https://github.com/RekGRpth/pg_curl) и планировщика асинхронных заданий [pg_task](https://github.com/RekGRpth/pg_task).
На таблицу с сообщениями я навешал триггер, который после вставки создаёт задачу на отправку СМС. После успешной отправки создаётся задача на проверку статуса сообщения, которая периодически запускается до достижения окончательного статуса.
Также, я сделал интерфейс для массовой рассылки СМС по таблице из CSV-файла, в котором можно указать колонки с получателем, а также с другими переменными, которые будут подставляться в тело сообщения с помощью шаблонизатора [pg_mustach](https://github.com/RekGRpth/pg_mustach).
Кроме этого, я ещё сделал организацию рассылки СМС с суммами на оплату по условиям из биллинга.

3.Регистрация чеков в Атол

Регистрация чеков в Атол тоже происходит через REST-интерфейс. На таблицу с платежами я навешал триггер, который после вставки создаёт задачу на регистрацию чека. После успешной регистрации создаётся задача на проверку статуса регистрации, которая периодически запускается до достижения окончательного статуса.

4.Загрузка счетов в 1С

Понадобилось как-то загружать в 1С из биллинга следующую информацию: контрагентов, номенклатуру, реализацию товаров и услуг, счета на оплату и счета-фактуры. В качестве интерфейса к 1С выдали только REST-интерфейс OData.
Я быстренько сначала написал прототип загрузки на питоне с помощью нескольких функций. Поиск сущности по фильтру с выбором только заданных полей, возвращающий список найденных сущностей.
Чтение сущности с выбором только заданных полей по идентификатору сущности, возвращающее сущность. Создание новой сущности, которму передаётся тело сущности в виде json. Удаление сущности по её идентификатору.
И, наконец, обновление/изменение сущности по её идентификатору, которому передаётся только те поля сущности, которые надо поменять.
После проверки прототипа, я переписал все эти функции на PL/pgSQL, а для HTTP-запросов использовал свой плагин [pg_curl](https://github.com/RekGRpth/pg_curl) и конечно автоматизировал всё с помощью планировщика асинхронных заданий [pg_task](https://github.com/RekGRpth/pg_task).

5.Включение/отключение телефонии/интернета/телевидения

А ещё я сделал включение/отключение телефонии/интернета/телевидения прямо в базе!
Т.к. телефония у нас работала через постгрес, то её включение/отключение по балансу - это лишь некие SQL-команды, которые я автоматизировал с помощью планировщика асинхронных заданий [pg_task](https://github.com/RekGRpth/pg_task).
Интернет пришлось включать/отключать на цисках/микротиках через SSH с помощью плагина [plsh](https://github.com/petere/plsh). Конечно, это мог бы сделать и [curl](https://github.com/curl/curl), но у него нет поддержки выполнения SSH-команд, хотя мне как-то удалось её туда добавить в качестве эксперимента.
Телевидение включается/отключается через REST-интерфейс оборудования.
